package com.soc.webapp.action.knowledgemanger;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.apache.struts2.ServletActionContext;
import org.dom4j.DocumentException;

import com.soc.service.systemsetting.SettingService;
import com.soc.model.knowledge.Vulnerability;
import com.soc.model.systemsetting.Setting;
import com.soc.model.user.OnlineUser;
import com.soc.model.user.User;
import com.soc.service.audit.AuditService;
import com.soc.service.knowledge.VulnerabilityService;
import com.soc.service.knowledge.exportleak.ExcelVulnerability;
import com.soc.service.knowledge.impl.VulnerabilityServiceImpl;
import com.soc.service.knowledge.importLeak.ImportVulnerability;
import com.soc.webapp.action.BaseAction;
import com.util.DateUtil;

import com.util.EnvVulnerability;
import com.util.FileUtil;
import com.util.ReadXML;
import com.util.SessionContext;
import com.util.StringUtil;
import com.util.ThreadPool;
import com.util.page.Page;
import com.util.page.SearchResult;

/**
 * 
 * <漏洞Action> <對漏洞的相關操作：查詢漏洞、刪除漏洞、修改漏洞、导入导出漏洞库>
 * 
 * @author 曹理冬
 * @version [V100R001C001]
 * @see [BaseAction,VulnerabilityServiceImpl,VulnerabilityTypeServiceImpl]
 * @since [scan v3.6.0.1]
 */
public class VulnerabilityAction extends BaseAction
{
    private static final long serialVersionUID = 1L;
    
    // 漏洞信息
    private Vulnerability vulnerability;
    
    // 漏洞信息List
    private List<Vulnerability> vulnerabilityList;
    
    // 漏洞服务类
    private VulnerabilityService vulnerabilityManager;
    
    // 关键字
    private String keyword;
    
    // 高级查询漏洞编号
    private String selVulnerabilityUniqueIdentification;
    
    // 高级查询漏洞名称
    private String selVulnerabilityName;
    
    // 高级查询漏洞类型
    private String selVulnerabilityType;
    
    // 高级查询风险等级
    private String selVulnerabilityRiskFactor;
    
    // 高级查询描述
    private String selVulnerabilitySynopsis;
    
    // 批量操作复选框的值
    private String ids;
    
    // 存储漏洞ID
    private long vulnerabilityId;
    
    // 导入路径
    private File upTar;
    
    // 存放导入文件的路径
    private String upTarFileName;
    
    //存漏洞类型
    private List<String> listVulnerabilityType;
    
    //漏洞库升级标识
    private String upgradeFlag;
    
    //系统设置业务类
    private SettingService settingManager;
    
    //存储漏洞编号
    private String vulnerabilityUniqueIdentification;
    
    //存储漏洞类型
    private List<String> vulnerabilityTypeName;
    
    //xml标签
    private String oid;
    
    //存储漏洞的键值对
    Map<String, Object> map = new HashMap<String, Object>();
    
    //存储漏洞xml的路径
    List<String> list = new ArrayList<String>();
    
    //存储要插入的漏洞
    private List<Map<String, Object>> mapList = new ArrayList<Map<String, Object>>();
    
    //漏洞库内已有的漏洞编号列表
    private List<String> vulnerabilityListoid = new ArrayList<String>();
    
    //记录漏洞记录
    private int count = 0;
    
    //线程池
    public static ThreadPool threadPool = null;
    
    //路径
    public static String path;
    
    //漏洞升级百分比
    public static String upgradePercent = "0";
    
    //漏洞文件名称
    private String vulnerabilityFileName;
    
    //漏洞脚本信息
    private String src;
    
    public static File upgrade1;
    
    //漏洞库升级完成时间
    private String upgradeTime;
    
    private boolean upStatr = false;
    
  
    //请求的action字符串
    private String actionStr ="query.action"; 
    
    // 排序Type
    private String sortType;
    
    // 要查询的字段
    private String field ; 
    
	// 审计业务管理类
	private AuditService auditManager;
    
    /**
     * 根据ID查询漏洞信息
     * 
     * @return String
     * @see VulnerabilityServiceImpl#queryVulnerabilityById(long)
     * @see VulnerabilityTypeServiceImpl#queryVulnerabilityType()
     */
    public String editVulnerability()
    {
        LOG.info("[VulnerabilityAction] enter method editVulnerability()....");
        
        vulnerability = vulnerabilityManager.queryVulnerabilityById(vulnerabilityId);
        
        //查询库内的漏洞类型
        listVulnerabilityType = vulnerabilityManager.queryVulnerabilityType();
        //从查询到的类别中去掉vulnerability的级别,否则将会显示两个相同的级别
        String tempType = vulnerability.getVulnerabilityType();
        for (int i = 0; i < listVulnerabilityType.size(); i++)
        {
            if (tempType.equals(listVulnerabilityType.get(i)))
            {
                listVulnerabilityType.remove(i);
            }
        }
        
        return SUCCESS;
    }
    
    /**
     * 修改漏洞信息
     * 
     * @return String
     * @see VulnerabilityServiceImpl#updateVulnerability(Vulnerability)
     */
    public String updateVulnerability()
    {
        LOG.info("[VulnerabilityAction] enter method updateVulnerability()...");
        
        vulnerabilityManager.updateVulnerability(vulnerability);
        
        List<String> fieldList = new ArrayList<String>();
		fieldList.add(vulnerability.getVulnerabilityName() + "("+ vulnerability.getVulnerabilityName() +")");
        // 审计日志
		auditManager.insertByInsertOperator(((User) this.getSession()
				.getAttribute("SOC_LOGON_USER")).getUserId(), "公告信息", super
				.getRequest().getRemoteAddr(), fieldList);
        
        return SUCCESS;
    }
    
    /**
     * 根据 ID删除漏洞信息
     * 
     * @return String
     * @see VulnerabilityServiceImpl#deleteVulnerability(long)
     */
    public String deleteVulnerability()
    {
        LOG.info("[VulnerabilityAction] enter method deleteVulnerability()...");
        
        if (ids.indexOf(",") > 0)
        {
            String[] checked = ids.split(",");
            
            for (String checkid : checked)
            {
                vulnerabilityManager.deleteVulnerability(Integer.parseInt(checkid));
            }
            
            List<String> fieldList = new ArrayList<String>();
    		fieldList.add("漏洞信息 ( 漏洞信息 )");
            // 审计日志
    		auditManager.insertBySystemOperator(((User) this.getSession()
    				.getAttribute("SOC_LOGON_USER")).getUserId(), "批量删除漏洞信息", super
    				.getRequest().getRemoteAddr(), fieldList);
            
        }
        
        // 针对单条记录操作
        else
        {
            vulnerabilityManager.deleteVulnerability(Long.parseLong(ids));
            
            List<String> fieldList = new ArrayList<String>();
    		fieldList.add("漏洞信息 ( 漏洞信息 )");
            // 审计日志
    		auditManager.insertByDeleteOperator(((User) this.getSession()
    				.getAttribute("SOC_LOGON_USER")).getUserId(), "漏洞信息", super
    				.getRequest().getRemoteAddr(), fieldList);
        }
        
        return SUCCESS;
    }
    
    /**
     * 导出漏洞信息
     * 
     * @return String
     * @see VulnerabilityServiceImpl#exportVulnerability(Map)
     */
    public void checkExport()
    {
        LOG.info("[VulnerabilityAction] enter method checkExport() ...");
        
        HttpServletResponse response = super.getResponse();
        ExcelVulnerability excelsys = new ExcelVulnerability();
        Map<String, String> limit = new HashMap<String, String>();
        if (StringUtil.isNotBlank(ids))
        {
            limit.put("ids", ids);
        }
        if (StringUtil.isNotBlank(keyword))
        {
            try
            {
                keyword = java.net.URLDecoder.decode(keyword, "UTF-8");
            }
            catch (UnsupportedEncodingException e)
            {
                e.printStackTrace();
            }
            limit.put("keyword", keyword);
        }
		// 高级查询
		
		if (StringUtil.isNotBlank(selVulnerabilityUniqueIdentification)) {
			 try
	            {
				 selVulnerabilityUniqueIdentification = java.net.URLDecoder.decode(selVulnerabilityUniqueIdentification, "UTF-8");
	            }
	            catch (UnsupportedEncodingException e)
	            {
	                e.printStackTrace();
	            }
			limit.put("selvulnerabilityUniqueIdentification",
					selVulnerabilityUniqueIdentification.trim());
//			keyword = selVulnerabilityUniqueIdentification;
		}
		if (StringUtil.isNotBlank(selVulnerabilityName)) {
			 try
	            {
				 selVulnerabilityName = java.net.URLDecoder.decode(selVulnerabilityName, "UTF-8");
	            }
	            catch (UnsupportedEncodingException e)
	            {
	                e.printStackTrace();
	            }
			limit.put("selvulnerabilityName", selVulnerabilityName.trim());
		}
		if (StringUtil.isNotBlank(selVulnerabilityType)) {
			 try
	            {
				 selVulnerabilityType = java.net.URLDecoder.decode(selVulnerabilityType, "UTF-8");
	            }
	            catch (UnsupportedEncodingException e)
	            {
	                e.printStackTrace();
	            }
			limit.put("selvulnerabilityType", selVulnerabilityType.trim());
		}
		if (StringUtil.isNotBlank(selVulnerabilityRiskFactor)) {
			 try
	            {
				 selVulnerabilityRiskFactor = java.net.URLDecoder.decode(selVulnerabilityRiskFactor, "UTF-8");
	            }
	            catch (UnsupportedEncodingException e)
	            {
	                e.printStackTrace();
	            }
			limit.put("selvulnerabilityRiskFactor", selVulnerabilityRiskFactor.trim());
		}
		if (StringUtil.isNotBlank(selVulnerabilitySynopsis)) {
			 try
	            {
				 selVulnerabilitySynopsis = java.net.URLDecoder.decode(selVulnerabilitySynopsis, "UTF-8");
	            }
	            catch (UnsupportedEncodingException e)
	            {
	                e.printStackTrace();
	            }
			limit.put("selvulnerabilitySynopsis", selVulnerabilitySynopsis.trim());

		}
        excelsys.export(vulnerabilityManager.exportVulnerability(limit), "漏洞管理Excel报表");
        try
        {
            // 中文文件名需要编码
            String fileName = "vulnerabilitylog_" + DateUtil.curDateStr8();
            response.setContentType("application/ms-excel");
            response.setHeader("Content-Disposition", "attachment;Filename=" + fileName + ".xls");
            OutputStream os = response.getOutputStream();
            excelsys.getGwb().write(os);
            os.flush();
            os.close();
            
        }
        catch (FileNotFoundException e)
        {
            e.printStackTrace();
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }
    }
    
    /**
     * 导入漏洞信息
     * 
     * @return String
     * @see
     */
    public String importVulnerability()
    {
        LOG.info("[VulnerabilityAction] enter method importVulnerability()...");
        log.info(upTar + "                     " + upTarFileName);
        Map<String, Object> map = new HashMap<String, Object>();
        
        // 获取文件所上传文件所放的路径
        String path1 = ServletActionContext.getServletContext().getRealPath("/import");
        
        File importExcel = new File(new File(path1), upTarFileName);
        
        try
        {
            FileUtil.copyFile(upTar, importExcel);
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }
        /*	File file = new File(upTarFileName);

        	upTar = file;

        	String fileName = file.getName().toLowerCase();

        	File upgrade = new File(new File(path1), fileName);

        	if (!upgrade.getParentFile().exists()) {
        		upgrade.getParentFile().mkdirs();

        	}

        	// 复制页面传过来的文件
        	try {
        		FileUtils.copyFile(upTar, upgrade);
        	} catch (IOException e) {
        		e.printStackTrace();
        	}*/
        List<Vulnerability> list = new ArrayList<Vulnerability>();
        
        try{
        // 解析Excel表中的内容
        list = ImportVulnerability.readRead(upTar);

       
        
        // 循环Excel的条数
        for (int i = 0; i < list.size(); i++)
        {
            // 获取Excel表中的漏洞编号
            vulnerabilityUniqueIdentification = list.get(i).getVulnerabilityUniqueIdentification();
            
            List<Vulnerability> vulnerability = new ArrayList<Vulnerability>();
            
            vulnerability =
                vulnerabilityManager.queryVulnerabilityByUniqueIdentification(vulnerabilityUniqueIdentification);
            // 判断查询后是否为0，若等于0，则说明数据库没有相同的漏洞
            if (vulnerability.size() == 0)
            {
                vulnerabilityManager.importVulnerability(list.get(i));
            }
            else
            {
                list.get(i).setVulnerabilityIsDelete(0);
                vulnerabilityManager.importUpdateVulnerability(list.get(i));
                
            }
        }
        
        List<String> fieldList = new ArrayList<String>();
		fieldList.add("漏洞信息 ( 漏洞信息 )");
        // 审计日志
		auditManager.insertBySystemOperator(((User) this.getSession()
				.getAttribute("SOC_LOGON_USER")).getUserId(), "导入漏洞信息", super
				.getRequest().getRemoteAddr(), fieldList);
        
        }catch(Exception e){
        	try {
				field = java.net.URLDecoder.decode("%25E5%25AE%2589%25E5%2585%25A8%25E8%25BF%2590%25E8%25A1%258C%25E7%258A%25B6%25E6%2580%2581%25E6%258A%25A5%25E5%25AE%258C%25E6%2588%2590%25E8%25A1%25A8", "GBK");
			} catch (UnsupportedEncodingException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
        	//field = "导入的xls文件无法解析，请核对" ;
        	e.printStackTrace() ; 
        }
        
        return SUCCESS;
    }
    
    /**
     * 进入升级页面时
     * <功能详细描述>
     * @return
     * @see [类、类#方法、类#成员]
     */
    public String showSettingUpdate()
    {
        log.info("[SettingUpdateAction] enter method showSettingUpdate....");
        //获得库内的漏洞库升级标识
        
        
        //获得上次升级完成的时间
        upgradeTime = settingManager.queryByKey("upgrade_dateTime");
        
        return SUCCESS;
    }
    
    /**
     * <漏洞升级>
     * <功能详细描述>
     * @return String
     * @see [类、类#方法、类#成员]
     */
    public void settingUpdate()
    {
        
        log.info("[SettingUpdateAction] settingUpdate...");
        
        //将升级进度置为0
        upgradePercent = "0";
        
        //获得服务器的路径
        path = ServletActionContext.getServletContext().getRealPath("/upgrade");
        
        upgradeFlag = settingManager.queryByKey("upgrade");
        
        if (!upgradeFlag.equals("1"))
        {
            
            threadPool = new com.util.ThreadPool(1);
            
            try
            {
                Thread.sleep(1000);
            }
            catch (InterruptedException e)
            {
                e.printStackTrace();
            }
            
            threadPool.execute(createThread());
        }
        
        HttpSession session = super.getSession();
        
        SessionContext myc = SessionContext.getInstance();
        
        //清空服务器上除此用户以外的所有用户的session
        List<OnlineUser> userList = (List<OnlineUser>)super.getServletContext().getAttribute("SOC_ONLINE_USERLIST");
        
        if (userList != null)
        {
            for (OnlineUser user : userList)
            {
                HttpSession Sess = myc.getSession(user.getSessionId());
                if (Sess != null)
                {
                    if (!Sess.getAttribute("SOC_LOGON_USER").equals(session.getAttribute("SOC_LOGON_USER")))
                    {
                        Sess.invalidate();
                        userList.remove(user);
                    }
                }
            }
        }
        try
        {
            String script =
                "<script language=javascript>parent.parent.top.location.href='/soc/pages/commons/603.jsp'"
                    + "</script>";
            super.getResponse().getWriter().print(script);
        }
        catch (IOException e)
        {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
    
    /**
     * <查询指定文件夹下的所有子文件的路径>
     * <功能详细描述>
     * @param p String
     * @return List<String>
     * @see [类、类#方法、类#成员]
     */
    public List<String> find(String p)
    {
        //编译传过来的路径
        File file = new File(p);
        
        File[] files = file.listFiles();
        
        //循环传过来的路径中有几个文件
        for (int i = 0; i < files.length; i++)
        {
            
            if (files[i].isDirectory())
            {
                //判断是不是文件夹，如果是文件夹则继续向下查找文件
                find(files[i].getAbsolutePath());
            }
            else
            {
                //获取文件中子文件的路径(改动)
                String filePath = files[i].getAbsolutePath()/*.toLowerCase()*/;
                
                //把获取的到路径放入LIST
                list.add(filePath);
            }
        }
        return list;
    }
    
    /**
     * 删除指定目录下的文件
     * 
     * @param p
     * @see [类、类#方法、类#成员]
     */
    public void delteFile(String p)
    {
        //编译传过来的路径
        File file = new File(p);
        
        File[] files = file.listFiles();
        
        //循环传过来的路径中有几个文件
        for (int i = 0; i < files.length; i++)
        {
            
            if (files[i].isDirectory())
            {
                //判断是不是文件夹，如果是文件夹则继续向下查找文件
                File f = files[i];
                
                delteFile(files[i].getAbsolutePath());
                
                f.delete();
            }
            else
            {
                //删除文件
                files[i].delete();
            }
        }
    }
    
    /**
     * 创建线程来执行漏洞库升级操作
     * <功能详细描述>
     * @return
     * @see [类、类#方法、类#成员]
     */
    public Runnable createThread()
    {
        return new Runnable()
        {
            public void run()
            {
                update();
            }
        };
    }
    
    /**
     * 执行升级主函数
     * <功能详细描述>
     * @see [类、类#方法、类#成员]
     */
    public void update()
    {
        log.info("[SettingUpdateAction] enter method update.....");
        
        long begin = System.currentTimeMillis();
        
        //System.out.println(begin);
        
        Setting setting1 = new Setting();
        setting1.setKey("upgrade");
        setting1.setValue("1");
        settingManager.updateByKey("upgrade", setting1);
        
        //如果复选框勾上，则删除漏洞库全部信息
        if (!ids.equals(""))
        {
            vulnerabilityManager.deleteVulnerability();    
        }
        //执行解压命令
        try
        {
            try
            {
                Thread.sleep(3000);
            }
            catch (InterruptedException e)
            {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
            
           // path = ServletActionContext.getServletContext().getRealPath("/upgrade");
            
           //path ="/usr/local/tomcat6/webapps/soc/upgrade";
            
            /*//System.out.println(upgrade1);
            
            //System.out.println("链表路径"+path);
            
            //System.out.println("tar -zxvf " + upgrade1 + " -C " + path);
            */
            //执行解压命令
            Process ps = Runtime.getRuntime().exec("tar -zxvf " + upgrade1 + " -C " + path);
            
            BufferedReader br = new BufferedReader(new InputStreamReader(ps.getInputStream()));
            
            StringBuffer sb = new StringBuffer();
           
            String line;
            
            while ((line = br.readLine()) != null) {
                
            //sb.append(line).append(”\n”);
            }
            try
            {
                Thread.sleep(10000);
            }
            
            catch (InterruptedException e)
            {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }
        
        /*Runtime run = Runtime.getRuntime();
        
        try
        {
            run.exec("chmod 755 /usr/local/tomcat6/webapps/soc/sh/upgrade_vulnerability.sh");
            
            Process pro= run.exec("/usr/local/tomcat6/webapps/soc/sh/upgrade_vulnerability.sh"+" "+upgrade1+" "+path);                
            try
            {
                Thread.sleep(10000);
            }
            catch (InterruptedException e)
            {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
            
            ////System.out.println("循环个数+------"+exitVal);
        }
        catch (IOException e1)
        {
            // TODO Auto-generated catch block
            e1.printStackTrace();
        }
        */
        
        List<String> list = new ArrayList<String>();
        
        //调Find方法查询出upgrade文件下所有的XML文件路径，放入LIST(测试)
        list = find(path);
        
        //获得库内所有的漏洞编号
        vulnerabilityListoid = vulnerabilityManager.queryAllIdentification();
        
        //循环LIST,将所有路径逐一进行解析
        for (int i = 0; i < list.size(); i++)
        {
            try
            {
                map = ReadXML.TestJava(list.get(i));
                
                Map<String, Object> map1 = new HashMap<String, Object>();
                
                Set<String> set = map.keySet();
                
                Iterator<String> it = set.iterator();
                
                while (it.hasNext())
                {
                    String name = (String)it.next();
                    
                    map1.put(EnvVulnerability.getString(name), map.get(name));
                }
                
                //更新库内的漏洞升级进度
                upgradePercent = String.valueOf((i * 100 / list.size()));
                
                //判断查询ID后，是否有相同的漏洞编号，若没有添加到漏洞列表内
                if (!vulnerabilityListoid.contains(vulnerabilityUniqueIdentification))
                {
                    //添加漏洞到列表内
                    mapList.add(map1);
                    
                    //计数器加1
                    count++;
                    
                    //判断计数器是否到达4000
                    if (count == 4000)
                    {
                        //执行插入操作
                        vulnerabilityManager.upgradeVulnerability(mapList);
                        
                        //清空计数器
                        count = 0;
                        //清空里面的值
                        mapList.clear();
                    }
                }
            }
            catch (DocumentException e)
            {
                e.printStackTrace();
            }
        }
        
        //执行插入
        vulnerabilityManager.upgradeVulnerability(mapList);
        
        //将进度置为100%
        upgradePercent = "100";
        
        long end = System.currentTimeMillis();
        
        //System.out.println("时间为" + (end - begin));
        
        //删除文件
        // delteFile(path);
        
        HttpServletRequest request = super.getRequest();
        
        upgradeTime = DateUtil.curDateTimeStr19();
        
        //将升级标识置为已完成标识
        upgradeFlag = "2";
        
        //修改系统设置库内的漏洞升级完成时间,并且入库
        Setting setting = new Setting();
        setting.setKey("upgrade_dateTime");
        setting.setValue(upgradeTime);
        settingManager.updateByKey("upgrade_dateTime", setting);
        
        //修改库内的漏洞库升级标识
        setting.setKey("upgrade");
        setting.setValue("2");
        settingManager.updateByKey("upgrade", setting);
        
        //关闭线程池
        threadPool.closePool();
        
    }
    
    /**
     * <文件上传>
     * <功能详细描述>
     * @return
     * @see [类、类#方法、类#成员]
     */
    public String uptar()
    {
        
        path = ServletActionContext.getServletContext().getRealPath("/upgrade");
        
        if (upTar != null && upTarFileName != null)
        {
            
            upgrade1 = new File(new File(path), upTarFileName);
            
            
            if (!upgrade1.getParentFile().exists())
            {
                upgrade1.getParentFile().mkdirs();
            }
            try
            {
                upStatr = FileUtil.copyFile(upTar, upgrade1);
            }
            catch (IOException e)
            {
                e.printStackTrace();
            }
        }
        
        return SUCCESS;
    }
    
    /**
     * 显示漏洞升级的进度
     * <功能详细描述>
     * @see [类、类#方法、类#成员]
     */
    public void showUpdatePercent()
    {
        try
        {
            getResponse().getWriter().write(upgradePercent);
        }
        catch (IOException e)
        {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
    
    public Vulnerability getVulnerability()
    {
        return vulnerability;
    }
    
    public void setVulnerability(Vulnerability vulnerability)
    {
        this.vulnerability = vulnerability;
    }
    
    public List<Vulnerability> getVulxvfnerabilityList()
    {
        return vulnerabilityList;
    }
    
    public void setVulnerabilityList(List<Vulnerability> vulnerabilityList)
    {
        this.vulnerabilityList = vulnerabilityList;
    }
    
    public String getKeyword()
    {
        return keyword;
    }
    
    public void setKeyword(String keyword)
    {
        this.keyword = keyword;
    }
    
    public static long getSerialversionuid()
    {
        return serialVersionUID;
    }
    
    public String getSelVulnerabilityUniqueIdentification()
    {
        return selVulnerabilityUniqueIdentification;
    }
    
    public void setSelVulnerabilityUniqueIdentification(String selVulnerabilityUniqueIdentification)
    {
        this.selVulnerabilityUniqueIdentification = selVulnerabilityUniqueIdentification;
    }
    
    public String getSelVulnerabilityName()
    {
        return selVulnerabilityName;
    }
    
    public void setSelVulnerabilityName(String selVulnerabilityName)
    {
        this.selVulnerabilityName = selVulnerabilityName;
    }
    
    public String getSelVulnerabilityType()
    {
        return selVulnerabilityType;
    }
    
    public void setSelVulnerabilityType(String selVulnerabilityType)
    {
        this.selVulnerabilityType = selVulnerabilityType;
    }
    
    public String getIds()
    {
        return ids;
    }
    
    public void setIds(String ids)
    {
        this.ids = ids;
    }
    
    public long getVulnerabilityId()
    {
        return vulnerabilityId;
    }
    
    public void setVulnerabilityId(long vulnerabilityId)
    {
        this.vulnerabilityId = vulnerabilityId;
    }
    
    public String getSelVulnerabilityRiskFactor()
    {
        return selVulnerabilityRiskFactor;
    }
    
    public void setSelVulnerabilityRiskFactor(String selVulnerabilityRiskFactor)
    {
        this.selVulnerabilityRiskFactor = selVulnerabilityRiskFactor;
    }
    
    public String getSelVulnerabilitySynopsis()
    {
        return selVulnerabilitySynopsis;
    }
    
    public void setSelVulnerabilitySynopsis(String selVulnerabilitySynopsis)
    {
        this.selVulnerabilitySynopsis = selVulnerabilitySynopsis;
    }
    
    public File getUpTar()
    {
        return upTar;
    }
    
    public void setUpTar(File upTar)
    {
        this.upTar = upTar;
    }
    
    public String getUpTarFileName()
    {
        return upTarFileName;
    }
    
    public void setUpTarFileName(String upTarFileName)
    {
        this.upTarFileName = upTarFileName;
    }
    
    public String getVulnerabilityUniqueIdentification()
    {
        return vulnerabilityUniqueIdentification;
    }
    
    public void setVulnerabilityUniqueIdentification(String vulnerabilityUniqueIdentification)
    {
        this.vulnerabilityUniqueIdentification = vulnerabilityUniqueIdentification;
    }
    
    public VulnerabilityService getVulnerabilityManager()
    {
        return vulnerabilityManager;
    }
    
    public void setVulnerabilityManager(VulnerabilityService vulnerabilityManager)
    {
        this.vulnerabilityManager = vulnerabilityManager;
    }
    
    public List<String> getListVulnerabilityType()
    {
        return listVulnerabilityType;
    }
    
    public void setListVulnerabilityType(List<String> listVulnerabilityType)
    {
        this.listVulnerabilityType = listVulnerabilityType;
    }
    
    public List<String> getVulnerabilityTypeName()
    {
        return vulnerabilityTypeName;
    }
    
    public void setVulnerabilityTypeName(List<String> vulnerabilityTypeName)
    {
        this.vulnerabilityTypeName = vulnerabilityTypeName;
    }
    
    public String getOid()
    {
        return oid;
    }
    
    public void setOid(String oid)
    {
        this.oid = oid;
    }
    
    public Map<String, Object> getMap()
    {
        return map;
    }
    
    public void setMap(Map<String, Object> map)
    {
        this.map = map;
    }
    
    public List<String> getList()
    {
        return list;
    }
    
    public void setList(List<String> list)
    {
        this.list = list;
    }
    
    public List<Map<String, Object>> getMapList()
    {
        return mapList;
    }
    
    public void setMapList(List<Map<String, Object>> mapList)
    {
        this.mapList = mapList;
    }
    
    public List<String> getVulnerabilityListoid()
    {
        return vulnerabilityListoid;
    }
    
    public void setVulnerabilityListoid(List<String> vulnerabilityListoid)
    {
        this.vulnerabilityListoid = vulnerabilityListoid;
    }
    
    public String getPath()
    {
        return path;
    }
    
    public void setPath(String path)
    {
        this.path = path;
    }
    
    public String getVulnerabilityFileName()
    {
        return vulnerabilityFileName;
    }
    
    public void setVulnerabilityFileName(String vulnerabilityFileName)
    {
        this.vulnerabilityFileName = vulnerabilityFileName;
    }
    
    public String getSrc()
    {
        return src;
    }
    
    public void setSrc(String src)
    {
        this.src = src;
    }
    
    public File getUpgrade1()
    {
        return upgrade1;
    }
    
    public void setUpgrade1(File upgrade1)
    {
        this.upgrade1 = upgrade1;
    }
    
    public SettingService getSettingManager()
    {
        return settingManager;
    }
    
    public void setSettingManager(SettingService settingManager)
    {
        this.settingManager = settingManager;
    }
    
    public String getUpgradeTime()
    {
        return upgradeTime;
    }
    
    public void setUpgradeTime(String upgradeTime)
    {
        this.upgradeTime = upgradeTime;
    }
    
    public String getUpgradeFlag()
    {
        return upgradeFlag;
    }
    
    public void setUpgradeFlag(String upgradeFlag)
    {
        this.upgradeFlag = upgradeFlag;
    }
    
    public List<Vulnerability> getVulnerabilityList()
    {
        return vulnerabilityList;
    }
    
    public boolean isUpStatr()
    {
        return upStatr;
    }
    
    public void setUpStatr(boolean upStatr)
    {
        this.upStatr = upStatr;
    }


	/**
	 * 查询漏洞信息 高级查询，快速查询，分页显示
	 * 
	 * @return String
	 * @see VulnerabilityServiceImpl#count(Map)
	 * @see VulnerabilityServiceImpl#query(Map, Page)
	 */
	public String queryVulnerability() {
		LOG.info("[VulnerabilityAction] enter method queryVulnerability()...");

		HttpServletRequest request = super.getRequest();

		// 创建page对象
		Page page = null;
		SearchResult<Vulnerability> sr = null;

		// 处理数据分页的起始条数
		String startIndex = request.getParameter("startIndex");
		if (StringUtil.isNotBlank(startIndex)) {
			page = new Page(Page.DEFAULT_PAGE_SIZE, Integer.valueOf(startIndex));
		} else {
			page = new Page(Page.DEFAULT_PAGE_SIZE, 0);
		}

		// 接收查询条件，并存储到map中
		Map<String, Object> map = new HashMap<String, Object>();
		if (request.getParameter("keyword") != null) {
			try {
				keyword = java.net.URLDecoder.decode(keyword, "UTF-8");
			} catch (UnsupportedEncodingException e) {
				e.printStackTrace();
			}
			if(StringUtil.isNotEmpty(keyword)){
				map.put("keyword", keyword);
			}
			
		}
		// 高级查询
		
		if (StringUtil.isNotBlank(selVulnerabilityUniqueIdentification)) {
			map.put("selvulnerabilityUniqueIdentification",
					selVulnerabilityUniqueIdentification);
//			keyword = selVulnerabilityUniqueIdentification;
        	map.remove("keyword");
		}
		if (StringUtil.isNotBlank(selVulnerabilityName)) {
			map.put("selvulnerabilityName", selVulnerabilityName);
			map.remove("keyword");
		}
		if (StringUtil.isNotBlank(selVulnerabilityType)) {
			map.put("selvulnerabilityType", selVulnerabilityType);
			map.remove("keyword");
		}
		if (StringUtil.isNotBlank(selVulnerabilityRiskFactor)) {
			map.put("selvulnerabilityRiskFactor", selVulnerabilityRiskFactor);
			map.remove("keyword");
		}
		if (StringUtil.isNotBlank(selVulnerabilitySynopsis)) {
			map.put("selvulnerabilitySynopsis", selVulnerabilitySynopsis);
			map.remove("keyword");

		}

		// 根据map中存储的查询条件，查找符合条件的密码策略列表
		sr = vulnerabilityManager.query(map, page);
		vulnerabilityList = (List<Vulnerability>) sr.getList();

		request.setAttribute("Page", sr.getPage());

		return SUCCESS;
	}

	public String getActionStr() {
		return actionStr;
	}

	public void setActionStr(String actionStr) {
		this.actionStr = actionStr;
	}

	public String getSortType() {
		return sortType;
	}

	public void setSortType(String sortType) {
		this.sortType = sortType;
	}

	public String getField() {
		return field;
	}

	public void setField(String field) {
		this.field = field;
	}

	public AuditService getAuditManager() {
		return auditManager;
	}

	public void setAuditManager(AuditService auditManager) {
		this.auditManager = auditManager;
	}

	/**
	 * 查询漏洞信息 ，分页显示，排序
	 * 
	 * @return String
	 */
	public String sort(){
		
		LOG.info("[VulnerabilityAction] enter method sort() ...");
        HttpServletRequest request = super.getRequest();
        
        Page page = null;
        SearchResult sr = null;
        
        HttpSession session = this.getSession() ; 
        int changeNum=0;  
        changeNum = session.getAttribute("CHANGENUM")==null ? 1:(Integer)session.getAttribute("CHANGENUM");
        
     // 处理数据分页的起始条数
        String startIndex = request.getParameter("startIndex");
        
        if (StringUtil.isNotBlank(startIndex))
        {
            page = new Page(Page.DEFAULT_PAGE_SIZE, Integer.valueOf(startIndex));
        }
        else
        {
            page = new Page(Page.DEFAULT_PAGE_SIZE, 0);
        }
        
    	if(field != ""){
    		Map<String,String> map=new HashMap<String, String>();
    		int num = changeNum%2;
    		
    		if(num==0){
    			map.put("sortType", "DESC");
    		}else{
    			map.put("sortType", "ASC") ; 
    		}
    		if(sortType != null){
    			map.put("sortType", sortType);
    		}
    		map.put("field", field);
    		
    		actionStr = "field="+field+"&sortType="+map.get("sortType");
    		
    		sr = vulnerabilityManager.queryVulnerabilityBySort(map, page);
    		if (sr != null)
            {
    			vulnerabilityList = (List<Vulnerability>)sr.getList();
                //request.setAttribute("auditList", vulList);
                request.setAttribute("Page", sr.getPage());
            }
            else
            {
                request.setAttribute("Page", new Page(Page.DEFAULT_PAGE_SIZE, 0));
            }
    	}
    	changeNum++ ; 
    	session.setAttribute("CHANGENUM", changeNum);
    	return SUCCESS ; 
		
		
		
	}
	
	
	

	


}
